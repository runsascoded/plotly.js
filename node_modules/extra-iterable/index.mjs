function* accumulate(x, fr, acc) {
    var init = arguments.length <= 2, i = -1;
    for (var v of x) {
        if (init) {
            acc = v;
            init = false;
            ++i;
        }
        else
            acc = fr(acc, v, ++i, x);
        yield acc;
    }
}
function callable(x) {
    var xi = x[Symbol.iterator]();
    return () => xi.next().value;
}
function is(v) {
    return v != null && typeof v[Symbol.iterator] === "function";
}
function isOnce(v) {
    return is(v) && v[Symbol.iterator]() === v;
}
function manyLate(x, a) {
    return { [Symbol.iterator]: () => {
            var i = 0, xi = x[Symbol.iterator]();
            return { next: () => {
                    if (i < a.length)
                        return { value: a[i++], done: false };
                    var { value, done } = xi.next();
                    if (!done)
                        a[i++] = value;
                    return { value, done };
                } };
        } };
}
function many(x, now = false) {
    if (!isOnce(x))
        return x;
    return now ? Array.from(x) : manyLate(x, []);
}
function id(v) {
    return v;
}
function* cartesianProduct(xs, fm = null) {
    var fm = fm || id;
    var X = xs.length;
    if (X === 0)
        return;
    var is = [], os = [];
    for (var i = 0; i < X; i++) {
        xs[i] = i > 0 ? many(xs[i]) : xs[i];
        is[i] = xs[i][Symbol.iterator]();
        os[i] = is[i].next();
        if (os[i].done)
            return;
    }
    for (var i = 0;; i++) {
        var vs = [];
        for (var o of os)
            vs.push(o.value);
        yield fm(vs, i, null);
        for (var r = X - 1; r >= 0; r--) {
            os[r] = is[r].next();
            if (!os[r].done)
                break;
            is[r] = xs[r][Symbol.iterator]();
            os[r] = is[r].next();
        }
        if (r < 0)
            break;
    }
}
function* chunk(x, n = 1, s = n) {
    var M = Math.max(n, s);
    var m = 0, a = [];
    for (var v of x) {
        if (m < n)
            a.push(v);
        if (++m < M)
            continue;
        yield a;
        a = a.slice(s);
        m = a.length;
    }
    if (a.length > 0)
        yield a;
}
function cmp(a, b) {
    return a < b ? -1 : (a > b ? 1 : 0);
}
function compare(x, y, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var ix = x[Symbol.iterator]();
    var iy = y[Symbol.iterator]();
    for (var i = 0;; i++) {
        var u = ix.next();
        var v = iy.next();
        if (u.done || v.done)
            break;
        var u1 = fm(u.value, i, x);
        var v1 = fm(v.value, i, y);
        var c = fc(u1, v1);
        if (c !== 0)
            return c;
    }
    return (v.done ? 1 : 0) - (u.done ? 1 : 0);
}
function* concat(...xs) {
    for (var x of xs)
        yield* x;
}
const END = Number.MAX_SAFE_INTEGER;
function* slicePos(x, i, I) {
    var k = -1;
    for (var v of x) {
        if (++k >= I)
            break;
        if (k >= i)
            yield v;
    }
}
function* slicePosNeg(x, i, I) {
    var j = 0, k = -1;
    var a = [], A = -I;
    for (var v of x) {
        if (++k < i)
            continue;
        if (a.length >= A)
            yield a[j];
        a[j] = v;
        j = (j + 1) % A;
    }
}
function* sliceNeg(x, i, I) {
    var j = 0, n = 0;
    var a = [], A = -i;
    for (var v of x) {
        a[j] = v;
        j = (j + 1) % A;
        n++;
    }
    if (n < A)
        return;
    var I = I < 0 ? I : Math.min(I - n, 0);
    var n = Math.max(I - i, 0);
    var J = Math.max(j + n - A, 0);
    yield* a.slice(j, j + n);
    yield* a.slice(0, J);
}
function* slice(x, i = 0, I = END) {
    if (i >= 0 && I >= 0)
        yield* slicePos(x, i, I);
    else if (i >= 0 && I < 0)
        yield* slicePosNeg(x, i, I);
    else
        yield* sliceNeg(x, i, I);
}
function* copy(x, y, j = 0, i = 0, I = END) {
    var k = -1, J = -1;
    for (var u of x) {
        if (++k === j) {
            J = k;
            for (var v of slice(y, i, I)) {
                yield v;
                ++J;
            }
        }
        if (k >= j && k < J)
            continue;
        else
            yield u;
    }
    if (k < j) {
        for (; ++k < j;)
            yield undefined;
        yield* slice(y, i, I);
    }
}
function size(x, i = 0, I = END) {
    var j = -1, n = 0;
    for (var _ of x)
        if (++j >= i && j < I)
            n++;
    return n;
}
function* copyWithin(x, j = 0, i = 0, I = END) {
    var x = many(x), n = size(x);
    for (var v of copy(x, x, j, i, I)) {
        if (--n < 0)
            break;
        yield v;
    }
}
function id$1(v) {
    return v;
}
function cmp$1(a, b) {
    return a < b ? -1 : (a > b ? 1 : 0);
}
function count(x, ft) {
    var a = 0, i = -1;
    for (var v of x)
        if (ft(v, ++i, x))
            a++;
    return a;
}
function countAs(x, fm = null) {
    var fm = fm || id$1;
    var a = new Map(), i = -1;
    for (var v of x) {
        var v1 = fm(v, ++i, x);
        a.set(v1, (a.get(v1) || 0) + 1);
    }
    return a;
}
function from$(x) {
    return Array.isArray(x) ? x : [...x];
}
function from(vs, fm = null) {
    return new Set(fm ? from$(vs).map(fm) : vs);
}
function scanUntil(x, ft) {
    var i = -1;
    for (var v of x)
        if (ft(v, ++i, x))
            return i;
    return ++i;
}
function from$$1(x) {
    return Array.isArray(x) ? x : [...x];
}
function searchValue(x, v, fc = null, fm = null) {
    var fc = fc || cmp$1, fm = fm || id$1;
    var v1 = fm(v, 0, null), i = -1;
    for (var u of x) {
        var u1 = fm(u, ++i, x);
        if (fc(u1, v1) === 0)
            return i;
    }
    return -1;
}
function isDisjointMap(x, y, fm = null) {
    var s = from(y, fm);
    var fm = fm || id$1, i = -1;
    for (var u of x) {
        var u1 = fm(u, ++i, x);
        if (s.has(u1))
            return false;
    }
    return true;
}
function isDisjointDual(x, y, fc = null, fm = null) {
    var fc = fc || cmp$1, fm = fm || id$1;
    var y1 = [...y].map(fm), i = -1;
    for (var u of x) {
        var u1 = fm(u, ++i, x);
        for (var v1 of y1)
            if (fc(u1, v1) === 0)
                return false;
    }
    return true;
}
function isDisjoint(x, y, fc = null, fm = null) {
    if (fc)
        return isDisjointDual(x, y, fc, fm);
    return isDisjointMap(x, y, fm);
}
function isUniqueMap(x, fm = null) {
    var fm = fm || id$1;
    var s = new Set(), i = -1;
    for (var v of x) {
        var v1 = fm(v, ++i, x);
        if (s.has(v1))
            return false;
        s.add(v1);
    }
    return true;
}
function isUniqueDual(x, fc = null, fm = null) {
    var fc = fc || cmp$1, fm = fm || id$1;
    var x1 = [...x].map(fm);
    for (var u1 of x1) {
        for (var v1 of x1)
            if (fc(u1, v1) === 0)
                return false;
    }
    return true;
}
function isUnique(x, fc = null, fm = null) {
    if (fc)
        return isUniqueDual(x, fc, fm);
    else
        return isUniqueMap(x, fm);
}
function range(x, fc = null, fm = null) {
    var fc = fc || cmp$1, fm = fm || id$1;
    var mi = -1, mu, mv;
    var ni = -1, nu, nv;
    var i = -1;
    for (var u of x) {
        var v = fm(u, ++i, x);
        if (i === 0 || fc(v, mv) < 0) {
            mi = i;
            mu = u;
            mv = v;
        }
        if (i === 0 || fc(v, nv) > 0) {
            ni = i;
            nu = u;
            nv = v;
        }
    }
    return [[mi, mu], [ni, nu]];
}
function partition(x, ft) {
    var t = [], f = [], i = -1;
    for (var v of x) {
        if (ft(v, ++i, x))
            t.push(v);
        else
            f.push(v);
    }
    return [t, f];
}
function partitionAs(x, fm = null) {
    var fm = fm || id$1;
    var a = new Map(), i = -1;
    for (var v of x) {
        var v1 = fm(v, ++i, x);
        if (!a.has(v1))
            a.set(v1, []);
        a.get(v1).push(v);
    }
    return a;
}
function scanWhile(x, ft) {
    var i = -1;
    for (var v of x)
        if (!ft(v, ++i, x))
            return i;
    return ++i;
}
function count$1(x, ft) {
    return count(x, ft);
}
function countAs$1(x, fm = null) {
    return countAs(x, fm);
}
function* cut(x, ft) {
    var i = -1, a = [];
    for (var v of x) {
        if (ft(v, ++i, x)) {
            yield a;
            a = [];
        }
        a.push(v);
    }
    yield a;
}
function* cutAt(x, is) {
    var ii = is[Symbol.iterator]();
    var { value, done } = ii.next();
    if (done)
        value = END;
    var a = [], j = -1;
    for (var v of x) {
        if (++j < value) {
            a.push(v);
            continue;
        }
        yield a;
        a = [v];
        var { value, done } = ii.next();
        if (done)
            value = END;
    }
    yield a;
    for (; !done; { done } = ii.next())
        yield [];
}
function* map(x, fm) {
    var i = -1;
    for (var v of x)
        yield fm(v, ++i, x);
}
function* cutAtRight(x, is) {
    yield* cutAt(x, map(is, i => i + 1));
}
function* cutRight(x, ft) {
    var i = -1, a = [];
    for (var v of x) {
        a.push(v);
        if (ft(v, ++i, x)) {
            yield a;
            a = [];
        }
    }
    yield a;
}
function mod(x, y) {
    return x - y * Math.floor(x / y);
}
function* cycle(x, i = 0, n = -1) {
    var x = many(x);
    var i = i === 0 ? 0 : mod(i, size(x));
    while (true) {
        for (var v of x) {
            if (--i >= 0)
                continue;
            if (n-- === 0)
                return;
            yield v;
        }
    }
}
function from$$1$1(x) {
    return Array.isArray(x) ? x : [...x];
}
function from$1(vs, fm = null) {
    return new Set(fm ? from$$1$1(vs).map(fm) : vs);
}
function* differenceMap(x, y, fm = null) {
    var s = from$1(y, fm);
    var fm = fm || id, i = -1;
    for (var u of x) {
        var u1 = fm(u, ++i, x);
        if (!s.has(u1))
            yield u;
    }
}
function* differenceDual(x, y, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var y1 = [...y].map(fm), i = -1;
    x: for (var u of x) {
        var u1 = fm(u, ++i, x);
        for (var v1 of y1)
            if (fc(u1, v1) === 0)
                continue x;
        yield u;
    }
}
function* difference(x, y, fc = null, fm = null) {
    if (fc)
        yield* differenceDual(x, y, fc, fm);
    else
        yield* differenceMap(x, y, fm);
}
function* drop(x, n = 1) {
    yield* slice(x, n);
}
function* dropRight(x, n = 1) {
    if (n > 0)
        yield* slice(x, 0, -n);
    else
        yield* x;
}
function* dropWhile(x, ft) {
    var c = true, i = -1;
    for (var v of x) {
        c = c && ft(v, ++i, x);
        if (!c)
            yield v;
    }
}
function* dropWhileRight(x, ft) {
    var i = -1, a = [];
    for (var v of x) {
        if (ft(v, ++i, x))
            a.push(v);
        else {
            yield* a;
            yield v;
            a.length = 0;
        }
    }
}
function* entries(x) {
    var i = -1;
    for (var v of x)
        yield [++i, v];
}
function everyBool(x) {
    for (var v of x)
        if (!v)
            return false;
    return true;
}
function everyTest(x, ft) {
    var i = -1;
    for (var v of x)
        if (!ft(v, ++i, x))
            return false;
    return true;
}
function every(x, ft = null) {
    if (ft)
        return everyTest(x, ft);
    else
        return everyBool(x);
}
function* fill(x, v, i = 0, I = END) {
    var j = -1;
    for (var u of x) {
        if (++j >= i && j < I)
            yield v;
        else
            yield u;
    }
}
function* filter(x, ft) {
    var i = -1;
    for (var v of x)
        if (ft(v, ++i, x))
            yield v;
}
function* filterAt(x, is) {
    var i = -1;
    for (var v of x)
        if (is.includes(++i))
            yield v;
}
function find(x, ft) {
    var i = -1;
    for (var v of x)
        if (ft(v, ++i, x))
            return v;
}
function* findAll(x, ft) {
    yield* filter(x, ft);
}
function findRight(x, ft) {
    var i = -1, a;
    for (var v of x)
        if (ft(v, ++i, x))
            a = v;
    return a;
}
function isList(v) {
    return is(v) && typeof v !== "string";
}
function* flat(x, n = -1, fm = null, ft = null) {
    var fm = fm || id, ft = ft || isList, i = -1;
    for (var v of x) {
        var v1 = fm(v, ++i, x);
        if (n !== 0 && ft(v1, i, x))
            yield* flat(v1, n - 1, fm, ft);
        else
            yield v1;
    }
}
function* flatMap(x, fm = null, ft = null) {
    var fm = fm || id, ft = ft || isList, i = -1;
    for (var v of x) {
        var v1 = fm(v, ++i, x);
        if (ft(v1, i, x))
            yield* v1;
        else
            yield v1;
    }
}
function forEach(x, fc) {
    var i = -1;
    for (var v of x)
        fc(v, ++i, x);
}
function from$2(x) {
    if (typeof x[Symbol.iterator] === "function")
        return x;
    return { [Symbol.iterator]: () => x };
}
function* fromApply(fm = null, v, n = -1) {
    if (n !== 0)
        yield v;
    for (var i = 1; i !== n; i++)
        yield (v = fm(v, i, null));
}
function* fromCall(fc, ...as) {
    for (;;)
        yield fc(...as);
}
function* fromRange(v = 0, V = END, s = 1) {
    if (s >= 0) {
        for (; v < V; v += s)
            yield v;
    }
    else {
        for (; v > V; v += s)
            yield v;
    }
}
function get(x, i) {
    var j = -1;
    for (var v of x)
        if (++j === i)
            return v;
}
function* getAll(x, is) {
    var ii = is[Symbol.iterator]();
    var value = -1, j = -1;
    for (var v of x) {
        while (value <= j) {
            var { value, done } = ii.next();
            if (done)
                return;
            if (value <= j)
                yield undefined;
        }
        if (value === ++j)
            yield v;
    }
    while (!ii.next().done)
        yield undefined;
}
function getPath(x, p) {
    for (var i of p)
        x = is(x) ? get(x, i) : undefined;
    return x;
}
function* group(x, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var a = [], u1, i = -1;
    for (var v of x) {
        var v1 = fm(v, ++i, x);
        if (i > 0 && fc(u1, v1) !== 0) {
            yield a;
            a = [v];
        }
        else
            a.push(v);
        u1 = v1;
    }
    yield a;
}
function head(x, vd) {
    for (var v of x)
        return v;
    return vd;
}
function* searchInfixAll(x, y, fc, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var y1 = from$$1(y), Y = y1.length;
    if (Y === 0)
        yield 0;
    var y1 = y1.map(fm, null);
    var m = new Array(Y).fill(false);
    var i = -1, J = 0;
    for (var u of x) {
        var u1 = fm(u, ++i, x);
        for (var j = J; j > 0; j--)
            m[j] = m[j - 1] && fc(u1, y1[j]) === 0;
        m[0] = fc(u1, y1[0]) === 0;
        J = Math.min(J + 1, Y - 1);
        if (m[Y - 1])
            yield i - Y + 1;
    }
}
function searchInfix(x, y, fc, fm = null) {
    return head(searchInfixAll(x, y, fc, fm), -1);
}
function hasInfix(x, y, fc, fm = null) {
    return searchInfix(x, y, fc, fm) >= 0;
}
function hasPath(x, p) {
    return getPath(x, p) !== undefined;
}
function hasPrefix(x, y, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var ix = x[Symbol.iterator](), i = -1;
    for (var v of y) {
        var { value, done } = ix.next();
        if (done)
            return false;
        var u1 = fm(value, ++i, x);
        var v1 = fm(v, i, y);
        if (fc(u1, v1) !== 0)
            return false;
    }
    return true;
}
function searchSubsequence(x, y, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var iy = y[Symbol.iterator]();
    var { value, done } = iy.next();
    if (done)
        return 0;
    var i = -1, j = -1, a = -1;
    var v1 = fm(value, ++j, y);
    for (var u of x) {
        var u1 = fm(u, ++i, x);
        if (fc(u1, v1) !== 0)
            continue;
        if (a < 0)
            a = i;
        var { value, done } = iy.next();
        if (done)
            return a;
        v1 = fm(value, ++j, y);
    }
    return -1;
}
function hasSubsequence(x, y, fc = null, fm = null) {
    return searchSubsequence(x, y, fc, fm) >= 0;
}
function hasSuffix(x, y, fc, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var y1 = from$$1(y), Y = y1.length;
    var a = [], ai = 0, n = 0;
    if (Y === 0)
        return true;
    for (var u of x) {
        a[ai++ % Y] = u;
        n++;
    }
    if (a.length < Y)
        return false;
    for (var i = 0, j = n - Y; i < Y; i++, j++) {
        var u1 = fm(a[ai++ % Y], j, x);
        var v1 = fm(y1[i], i, y);
        if (fc(u1, v1) !== 0)
            return false;
    }
    return true;
}
function searchValue$1(x, v, fc = null, fm = null) {
    return searchValue(x, v, fc, fm);
}
function hasValue(x, v, fc = null, fm = null) {
    return searchValue$1(x, v, fc, fm) >= 0;
}
function includes(x, v, i = 0) {
    return hasValue(slice(x, i), v);
}
function index(x, i = 0) {
    var n = size(x);
    return i < 0 ? Math.max(n + i, 0) : Math.min(i, n);
}
function indexOf(x, v, i = 0) {
    var a = searchValue$1(slice(x, i), v);
    return a < 0 ? a : a + i;
}
function indexRange(x, i = 0, I = END) {
    var n = size(x);
    i = i < 0 ? Math.max(n + i, 0) : Math.min(i, n);
    I = I < 0 ? Math.max(n + I, 0) : Math.min(I, n);
    I = Math.max(i, I);
    return [i, I];
}
function* init(x) {
    var u, i = -1;
    for (var v of x) {
        if (++i > 0)
            yield u;
        u = v;
    }
}
function* interleave(xs) {
    var X = xs.length;
    var is = [], os = [];
    for (var n = 0, i = 0; n < X; n++) {
        is[i] = xs[i][Symbol.iterator]();
        os[i] = is[i].next();
        if (!os[i].done)
            i++;
    }
    for (var j = 0; i > 0; j++) {
        var vs = os.map(o => o.value);
        j %= i;
        yield vs[j];
        os[j] = is[j].next();
        if (!os[j].done)
            continue;
        is.splice(j, 1);
        os.splice(j, 1);
        i--;
    }
}
function* repeat(x, n = -1) {
    var x = many(x);
    for (; n !== 0; n--)
        yield* x;
}
function* intermix(x, y, m = 1, n = 1, s = m, t = n) {
    var x1 = chunk(x, m, s);
    var y1 = chunk(repeat(y), n, t);
    var iy = y1[Symbol.iterator](), i = -1;
    for (var u of x1) {
        if (++i > 0)
            yield* iy.next().value;
        yield* u;
    }
}
function* interpolate(x, fc) {
    var u, i = -1;
    for (var v of x) {
        if (++i > 0)
            yield fc(u, v);
        yield (u = v);
    }
}
function* intersectionMap(x, y, fm = null) {
    var s = from$1(y, fm);
    var fm = fm || id, i = -1;
    for (var u of x) {
        var u1 = fm(u, ++i, x);
        if (s.has(u1))
            yield u;
    }
}
function* intersectionDual(x, y, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var y1 = [...y].map(fm), i = -1;
    x: for (var u of x) {
        var u1 = fm(u, ++i, x);
        for (var v1 of y1)
            if (fc(u1, v1) === 0) {
                yield u;
                continue x;
            }
    }
}
function* intersection(x, y, fc = null, fm = null) {
    if (fc)
        yield* intersectionDual(x, y, fc, fm);
    else
        yield* intersectionMap(x, y, fm);
}
function* intersperse(x, v) {
    var i = -1;
    for (var u of x) {
        if (++i > 0)
            yield v;
        yield u;
    }
}
function isDisjoint$1(x, y, fc = null, fm = null) {
    return isDisjoint(x, y, fc, fm);
}
function isEmpty(x) {
    for (var _ of x)
        return false;
    return true;
}
function isEqual(x, y, fc = null, fm = null) {
    return compare(x, y, fc, fm) === 0;
}
function isIterator(v) {
    return v != null && typeof v.next === "function";
}
function isMany(v) {
    return !isOnce(v);
}
function isUnique$1(x, fc = null, fm = null) {
    return isUnique(x, fc, fm);
}
function iterator(x) {
    return x[Symbol.iterator]();
}
function join(x, sep = ",") {
    var a = "";
    for (var v of x)
        a += v + sep;
    return a.substring(0, a.length - sep.length);
}
function* keys(x) {
    var i = -1;
    for (var _ of x)
        yield ++i;
}
function last(x, vd) {
    var v = vd;
    for (var v of x)
        ;
    return v;
}
function searchValueRight(x, v, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var v1 = fm(v, 0, null), i = -1, j = -1;
    for (var u of x) {
        var u1 = fm(u, ++i, x);
        if (fc(u1, v1) === 0)
            j = i;
    }
    return j;
}
function lastIndexOf(x, v, i = END - 1) {
    return searchValueRight(slice(x, 0, i + 1), v);
}
function* left(x, n = 1) {
    yield* slice(x, 0, n);
}
function length(x, i = 0, I = END) {
    return size(x, i, I);
}
function range$1(x, fc = null, fm = null) {
    return range(x, fc, fm);
}
function max(x, fc = null, fm = null) {
    return range$1(x, fc, fm)[1];
}
function min(x, fc = null, fm = null) {
    return range$1(x, fc, fm)[0];
}
function* merge(xs, fc = null, fm = null) {
    var X = xs.length;
    var is = [], os = [];
    for (var n = 0, i = 0; n < X; n++) {
        is[i] = xs[i][Symbol.iterator]();
        os[i] = is[i].next();
        if (!os[i].done)
            i++;
    }
    while (i > 0) {
        var vs = os.map(o => o.value);
        var j = min(vs, fc, fm)[0];
        yield vs[j];
        os[j] = is[j].next();
        if (!os[j].done)
            continue;
        is.splice(j, 1);
        os.splice(j, 1);
        i--;
    }
}
function* middle(x, i = 0, n = 1) {
    yield* slice(x, i, i + n);
}
function* movePart(x, j, k, l) {
    var p = [], i = -1;
    for (var v of x) {
        if (++i < j || i >= l)
            yield v;
        else {
            p.push(v);
            if (i < l - 1)
                continue;
            yield* p.slice(k - j);
            yield* p.slice(0, k - j);
        }
    }
}
function* moveWithin(x, j = 0, i = 0, I = END) {
    if (j < i)
        yield* movePart(x, j, i, I);
    else
        yield* movePart(x, i, I, j);
}
function partition$1(x, ft) {
    return partition(x, ft);
}
function partitionAs$1(x, fm = null) {
    return partitionAs(x, fm);
}
function* pop(x) {
    yield* init(x);
}
function* push(x, ...vs) {
    yield* x;
    yield* vs;
}
function reduce(x, fr, acc) {
    var init = arguments.length <= 2, i = -1;
    for (var v of x) {
        if (init) {
            init = false;
            acc = v;
            ++i;
        }
        else
            acc = fr(acc, v, ++i, x);
    }
    return acc;
}
function* reject(x, ft) {
    var i = -1;
    for (var v of x)
        if (!ft(v, ++i, x))
            yield v;
}
function* rejectAt(x, is) {
    var i = -1;
    for (var v of x)
        if (!is.includes(++i))
            yield v;
}
function* splice(x, i = 0, n = END - i, ...vs) {
    var j = -1;
    for (var u of x) {
        if (++j < i || j >= i + n)
            yield u;
        else if (j === i)
            yield* vs;
    }
}
function* remove(x, i) {
    yield* splice(x, i, 1);
}
function* reverse(x) {
    var a = from$$1(x);
    for (var i = a.length - 1; i >= 0; i--)
        yield a[i];
}
function* right(x, n = 1) {
    if (n === 0)
        return;
    yield* slice(x, -n);
}
function* rotateLeft(x, n) {
    var a = [], i = -1;
    for (var v of x) {
        if (++i < n)
            a.push(v);
        else
            yield v;
    }
    if (++i >= n) {
        yield* a;
        return;
    }
    var n = n % i;
    yield* a.slice(n);
    yield* a.slice(-n);
}
function* rotateRight(x, n) {
    var a = Array.from(x);
    var n = n % a.length;
    yield* a.slice(-n);
    yield* a.slice(0, -n);
}
function* rotate(x, n = 0) {
    if (n === 0)
        yield* x;
    else if (n > 0)
        yield* rotateLeft(x, n);
    else
        yield* rotateRight(x, -n);
}
function scanUntil$1(x, ft) {
    return scanUntil(x, ft);
}
function scanUntilRight(x, ft) {
    var i = 0, a = 0;
    for (var v of x)
        if (ft(v, i++, x))
            a = i;
    return a;
}
function scanWhile$1(x, ft) {
    return scanWhile(x, ft);
}
function scanWhileRight(x, ft) {
    var i = 0, a = 0;
    for (var v of x)
        if (!ft(v, i++, x))
            a = i;
    return a;
}
function search(x, ft) {
    var i = -1;
    for (var v of x)
        if (ft(v, ++i, x))
            return i;
    return -1;
}
function* searchAll(x, ft) {
    var i = -1;
    for (var v of x)
        if (ft(v, ++i, x))
            yield i;
}
function searchInfixRight(x, y, fc, fm = null) {
    return last(searchInfixAll(x, y, fc, fm), -1);
}
function searchRight(x, ft) {
    var i = -1, a = -1;
    for (var v of x)
        if (ft(v, ++i, x))
            a = i;
    return a;
}
function* searchValueAll(x, v, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var v1 = fm(v, 0, null), i = -1;
    for (var u of x) {
        var u1 = fm(u, ++i, x);
        if (fc(u1, v1) === 0)
            yield i;
    }
}
function* set(x, i, v) {
    var j = -1;
    for (var u of x)
        yield (++j === i ? v : u);
    if (j >= i)
        return;
    for (; ++j < i;)
        yield undefined;
    yield v;
}
function* tail(x) {
    var i = -1;
    for (var v of x)
        if (++i > 0)
            yield v;
}
function* shift(x) {
    yield* tail(x);
}
function someBool(x) {
    for (var v of x)
        if (v)
            return true;
    return false;
}
function someTest(x, ft) {
    var i = -1;
    for (var v of x)
        if (ft(v, ++i, x))
            return true;
    return false;
}
function some(x, ft = null) {
    if (ft)
        return someTest(x, ft);
    else
        return someBool(x);
}
function* split(x, ft) {
    var a = [], i = -1;
    for (var v of x) {
        if (!ft(v, ++i, x))
            a.push(v);
        else if (a.length) {
            yield a;
            a = [];
        }
    }
    if (a.length)
        yield a;
}
function* splitAt(x, is) {
    var a = [], i = -1;
    for (var v of x) {
        if (!is.includes(++i))
            a.push(v);
        else if (a.length) {
            yield a;
            a = [];
        }
    }
    if (a.length)
        yield a;
}
function* swap(x, i, j) {
    if (i === j)
        yield* x;
    var k = Math.min(i, j);
    var l = Math.max(i, j);
    var m = [];
    var vk, i = -1;
    for (var v of x) {
        if (++i < k || i > l)
            yield v;
        else if (i === k)
            vk = v;
        else if (i < l)
            m.push(v);
        else {
            yield v;
            yield* m;
            yield vk;
        }
    }
}
function* symmetricDifference(x, y, fc = null, fm = null) {
    var x = many(x), y = many(y);
    yield* difference(x, y, fc, fm);
    yield* difference(y, x, fc, fm);
}
function* take(x, n = 1) {
    yield* slice(x, 0, n);
}
function* takeRight(x, n = 1) {
    if (n > 0)
        yield* slice(x, -n);
}
function* takeWhile(x, ft) {
    var i = -1;
    for (var v of x) {
        if (ft(v, ++i, x))
            yield v;
        else
            return;
    }
}
function* takeWhileRight(x, ft) {
    var i = -1, a = [];
    for (var v of x) {
        if (ft(v, ++i, x))
            a.push(v);
        else
            a.length = 0;
    }
    yield* a;
}
function* unionMap(x, y, fm = null) {
    var fm = fm || id;
    var s = new Set();
    var i = -1, j = -1;
    for (var u of x) {
        var u1 = fm(u, ++i, x);
        s.add(u1);
        yield u;
    }
    for (var v of y) {
        var v1 = fm(v, ++j, y);
        if (!s.has(v1))
            yield v;
    }
}
function* unionDual(x, y, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var x = many(x);
    yield* x;
    var x1 = [...x].map(fm), j = -1;
    y: for (var v of y) {
        var v1 = fm(v, ++j, y);
        for (var u1 of x1)
            if (fc(u1, v1) === 0)
                continue y;
        yield v;
    }
}
function* union(x, y, fc = null, fm = null) {
    if (fc)
        yield* unionDual(x, y, fc, fm);
    else
        yield* unionMap(x, y, fm);
}
function* uniqueMap(x, fm = null) {
    var fm = fm || id;
    var s = new Set(), i = -1;
    for (var v of x) {
        var v1 = fm(v, ++i, x);
        if (s.has(v1))
            continue;
        s.add(v1);
        yield v;
    }
}
function* uniqueDual(x, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var s = [], i = -1;
    x: for (var v of x) {
        var v1 = fm(v, ++i, x);
        for (var u1 of s)
            if (fc(u1, v1) === 0)
                continue x;
        s.push(v1);
        yield v;
    }
}
function* unique(x, fc = null, fm = null) {
    if (fc)
        yield* uniqueDual(x, fc, fm);
    else
        yield* uniqueMap(x, fm);
}
function* unshift(x, ...vs) {
    yield* vs;
    yield* x;
}
function* values(x) {
    yield* x;
}
function* zip(xs, fm = null, ft = null, vd) {
    var fm = fm || id, ft = ft || some;
    var X = xs.length;
    if (X === 0)
        return;
    var is = [], ds = [], vs = [];
    for (var r = 0; r < X; r++)
        is[r] = xs[r][Symbol.iterator]();
    for (var i = 0;; i++) {
        for (var r = 0; r < X; r++) {
            var { done, value } = is[r].next();
            ds[r] = done;
            vs[r] = done ? vd : value;
        }
        if (ft(ds))
            break;
        yield fm(vs.slice(), i, null);
    }
}
export { END, accumulate, callable, cartesianProduct, chunk, compare, concat, copy, copyWithin, count$1 as count, countAs$1 as countAs, cut, cutAt, cutAtRight, cutRight, cycle, difference, drop, dropRight, dropWhile, dropWhileRight, entries, every, fill, filter, filterAt, find, findAll, findRight, flat, flatMap, forEach, from$2 as from, fromApply, fromCall, fromRange, get, getAll, getPath, group, hasInfix, hasPath, hasPrefix, hasSubsequence, hasSuffix, hasValue, head, includes, index, indexOf, indexRange, init, interleave, intermix, interpolate, intersection, intersperse, is, isDisjoint$1 as isDisjoint, isEmpty, isEqual, isIterator, isList, isMany, isOnce, isUnique$1 as isUnique, iterator, join, keys, last, lastIndexOf, left, length, many, map, max, merge, middle, min, moveWithin, partition$1 as partition, partitionAs$1 as partitionAs, pop, push, range$1 as range, reduce, reject, rejectAt, remove, repeat, reverse, right, rotate, scanUntil$1 as scanUntil, scanUntilRight, scanWhile$1 as scanWhile, scanWhileRight, search, searchAll, searchInfix, searchInfixAll, searchInfixRight, searchRight, searchSubsequence, searchValue$1 as searchValue, searchValueAll, searchValueRight, set, shift, size, slice, some, splice, split, splitAt, swap, symmetricDifference, tail, take, takeRight, takeWhile, takeWhileRight, union, unique, unshift, values, zip };
